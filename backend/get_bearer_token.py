import requests
import os
from dotenv import load_dotenv
import sys
import argparse  # Add argparse for command-line arguments
import firebase_admin
from firebase_admin import credentials, auth

sys.path.append(".")  # Add project root to path

load_dotenv()

# --- Firebase Admin SDK Initialization ---
try:
    # Construct the path relative to the script's location or project root
    # Assumes .env defines GOOGLE_APPLICATION_CREDENTIALS relative to project root
    cred_path = os.getenv("GOOGLE_APPLICATION_CREDENTIALS")
    if not cred_path:
        raise ValueError("GOOGLE_APPLICATION_CREDENTIALS not found in .env file")
    # This line checks if the path exists relative to where the script is run
    if not os.path.exists(cred_path):
         # If not found, it tries resolving it relative to the script's directory
         script_dir = os.path.dirname(__file__)
         alt_cred_path = os.path.join(script_dir, cred_path)
         if os.path.exists(alt_cred_path):
             cred_path = alt_cred_path
         else:
            # If still not found, it raises an error showing both paths tried
            raise FileNotFoundError(f"Service account key file not found at {cred_path} or {alt_cred_path}")

    cred = credentials.Certificate(cred_path)
    # Check if the app is already initialized to avoid errors on re-runs
    if not firebase_admin._apps:
        firebase_admin.initialize_app(cred)
    print("Firebase Admin SDK initialized successfully.")
except Exception as e:
    print(f"Error initializing Firebase Admin SDK: {e}")
    # Optionally exit if Admin SDK is crucial for all operations
    # sys.exit(1)
# -----------------------------------------

def generate_test_token(email="fake@example.com", password=os.getenv("USER_PASSWORD")):
    """
    Get a Firebase ID token using email/password authentication and save to bearer.txt.

    Args:
        email (str): Email of the test user
        password (str): Password of the test user
    """
    # Get Web API Key
    web_api_key = os.getenv("FIREBASE_WEB_API_KEY")
    if not web_api_key:
        raise ValueError("FIREBASE_WEB_API_KEY not found in .env file")

    try:
        # Sign in with email/password
        sign_in_url = (
            "https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword"
        )
        sign_in_data = {"email": email, "password": password, "returnSecureToken": True}

        response = requests.post(
            sign_in_url, params={"key": web_api_key}, json=sign_in_data
        )
        response.raise_for_status()

        id_token = response.json()["idToken"]
        bearer_token = f"{id_token}"

        # Save to bearer.txt
        with open("bearer.txt", "w") as f:
            f.write(bearer_token)

        print(f"ID token for {email} has been saved to bearer.txt")
        return id_token

    except requests.exceptions.HTTPError as e:
        print(f"Authentication failed: {e.response.json()['error']['message']}")
    except Exception as e:
        print(f"Error generating token: {e}")
    return None # Return None on failure


def generate_token_from_uid(uid: str):
    """
    Get a Firebase ID token using a custom token generated by the Admin SDK for a specific UID.

    Args:
        uid (str): The User ID for which to generate the token.
    """
    web_api_key = os.getenv("FIREBASE_WEB_API_KEY")
    if not web_api_key:
        raise ValueError("FIREBASE_WEB_API_KEY not found in .env file")

    if not firebase_admin._apps:
        print("Firebase Admin SDK not initialized. Cannot create custom token.")
        return None

    try:
        # Create a custom token using Firebase Admin SDK
        custom_token = auth.create_custom_token(uid)

        # Exchange custom token for an ID token using REST API
        sign_in_url = (
            "https://identitytoolkit.googleapis.com/v1/accounts:signInWithCustomToken"
        )
        sign_in_data = {"token": custom_token.decode("utf-8"), "returnSecureToken": True} # Decode bytes to string

        response = requests.post(
            sign_in_url, params={"key": web_api_key}, json=sign_in_data
        )
        response.raise_for_status()

        id_token = response.json()["idToken"]
        bearer_token = f"{id_token}" # No 'Bearer ' prefix for raw token

        # Save to bearer.txt
        with open("bearer.txt", "w") as f:
            f.write(bearer_token)

        print(f"ID token for UID {uid} has been saved to bearer.txt")
        return id_token

    except auth.FirebaseAuthError as e:
        print(f"Firebase Admin SDK error creating custom token: {e}")
    except requests.exceptions.HTTPError as e:
        print(f"Custom token sign-in failed: {e.response.json()['error']['message']}")
    except Exception as e:
        print(f"Error generating token from UID: {e}")
    return None # Return None on failure


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate Firebase ID token.")
    parser.add_argument(
        "--method",
        choices=["email", "uid"],
        default="email",
        help="Method to generate token ('email' or 'uid'). Default is 'email'.",
    )
    parser.add_argument("--email", default="fake@example.com", help="Email for email method.")
    parser.add_argument("--password", help="Password for email method (uses USER_PASSWORD from .env if not provided).")
    parser.add_argument("--uid", help="User ID for uid method.")

    args = parser.parse_args()

    if args.method == "email":
        password = args.password or os.getenv("USER_PASSWORD")
        if not password:
            print("Error: Password must be provided via --password argument or USER_PASSWORD in .env file.")
        else:
            generate_test_token(email=args.email, password=password)
    elif args.method == "uid":
        if not args.uid:
            print("Error: User ID must be provided via --uid argument for the uid method.")
        # Ensure Admin SDK is initialized before attempting UID method
        elif not firebase_admin._apps:
             print("Error: Cannot use UID method because Firebase Admin SDK failed to initialize.")
        else:
            generate_token_from_uid(uid=args.uid)
